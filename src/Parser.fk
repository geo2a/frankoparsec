data ParseError = parseError

note 
  Consumes one symbol of any kind
item [Exception ParseError, State (List Char)] Char
item = get! >>= { nil       -> throw parseError {}
                | (x :: xs) -> put xs >> x} 

note
  Consumes item only if it satisfies given predicate 
sat {Char -> Bool} [Exception ParseError, State (List Char)] Char
sat p = item! >>= {c -> if (p c) then {c} else {throw parseError {}}} 

note
  Consumes item only if it is equal to specified char
char Char [Exception ParseError, State (List Char)] Char
char c = sat {x -> x =Char= c} 

note 
  Parse a specified string
string (List Char) [Exception ParseError, State (List Char)] (List Char)
string str = map char str   

note 
  Interpret parsing as statful computation with possible exceptions
parse {[ Exception ParseError, State (List Char)] X}
      (List Char) [] Either ParseError X
parse p str = catch ? state str ? p!

note 
  por {[Exception ParseError, State (List Char)] X} 
      {[Exception ParseError, State (List Char)] X} 
        [Exception ParseError, State (List Char)]
      {[Exception ParseError, State (List Char)] X}   
  por p1 p2 = get! >>= 
    {xs -> parse p1 xs >>= { (right str) -> p1
                           | (left  err) -> p2}
    }

note 
  Alternative-like operation: try first parser, if it fails -- try second one

  Type are as ugly as my life, we need something to make them look more pretty.

{[Exception ParseError, State (List Char)] X} <|> {[Exception ParseError, State (List Char)] X} 
  [Exception ParseError, State (List Char)] {[Exception ParseError, State (List Char)] X}   
p1 <|> p2 = get! >>= 
  {xs -> parse p1 xs >>= 
    { (right str) -> p1
    | (left  err) -> parse p2 xs >>= 
      { (right str) -> p2
      | (left  err) -> throw err {}
      }
    }
  }

note
  -- | Zero or more.
  many :: f a -> f [a]
  many v = many_v
    where
      many_v = some_v <|> pure []
      some_v = (fmap (:) v) <*> many_v

  many :: Parser a -> Parser [a]
  many p = many1 p +++ return []

  many1 :: Parser a -> Parser [a]
  many1 p = do {a <- p; as <- many p; return (a:as)}

many {[Exception ParseError, State (List Char)] X} 
     [] 
     {[Exception ParseError, State (List Char)] (List X)}
many p = many1 p <|> nil

note 
  many1 {[Exception ParseError, State (List Char)] X} 
       [] 
       {[Exception ParseError, State (List Char)] (List X)}
  many1 p = get! >>= {xs -> parse p xs >>= {}}  

many1 {[Exception ParseError, State (List Char)] X} 
     [] 
     {[Exception ParseError, State (List Char)] (List X)}
many1 p = {'a' :: nil} 

note 
  main [] Either ParseError (List Char)
  main = parse {string ('a' :: ('b' :: nil))} ('a' :: ('b' :: nil))

main [] Either ParseError Char
main = parse {({char 'b'} <|> {char 'a'})!} ('a' :: ('b' :: nil))

note 
  main [] Either ParseError Char
  main = catch ? state ('a' :: ('b' :: nil)) ? item! >> item!

  main [State (List Char)] Either ParseError Char
  main = catch ? item! >> item!

note 
  main [] Either ParseError (List Char)
  main = catch ? state ('a' :: ('b' :: nil)) ? string ('a' :: ('b' :: nil))

note 
  main [] Either ParseError Char
  main = catch ? state nil ? item!