data ParseError = parseError

-- Interpret parsing as stateful computation with possible exceptions
parse : {[Exception ParseError, State (List Char)] X} -> (List Char) -> 
        Either ParseError X
parse p str = catch (state str p!)

-- Consumes one symbol of any kind
item : [Exception ParseError, State (List Char)]Char
item! = on get! { nil       -> throw parseError
                | (x :: xs) -> put xs; x} 

-- Consumes item only if it satisfies given predicate
---- It seems like we have something wierd here:
---- p should be pure predicate of type {Char -> Bool}, but this doesn't 
---- typecheck :(
sat : {Char -> [Exception ParseError, State (List Char)]Bool} -> 
      [Exception ParseError, State (List Char)]Char
sat p = on item! {c -> if (p c) {c} {throw parseError}}

-- -- Consumes item only if it satisfies given predicate
-- sat : {Char -> Bool} -> [Exception ParseError, State (List Char)]Char
-- sat p = on item! {c -> if (p c) {c} {throw parseError}}

-- Consumes item only if it is equal to specified char
char : Char -> [Exception ParseError, State (List Char)]Char
char c = sat {x -> eqChar x c} 

-- Parse a specified string
string : (List Char) -> [Exception ParseError, State (List Char)](List Char)
string str = map char str   
 
-- Alternative-like operation: try first parser, if it fails -- try second one
---- Type are as ugly as my life, 
---- we need something to make them look more pretty.
por : {[Exception ParseError, State (List Char)] X} -> 
      {[Exception ParseError, State (List Char)] X} -> 
      [Exception ParseError, State (List Char)] X
por p1 p2 = 
  on (parse p1 get!) { (right _)  -> p1! 
                     | (left  _)  ->  on (parse p2 get!) 
                       { (right _)   -> p2!
                       | (left err)  -> throw err
                       }
                     }

-- Zero or more 
many : {[Exception ParseError, State (List Char)]X} ->
       [Exception ParseError, State (List Char)](List X)
many p = por {some p} {nil}

-- One or more
some : {[Exception ParseError, State (List Char)] X} ->
       [Exception ParseError, State (List Char)](List X)
some p = p! :: many p

letter : [Exception ParseError, State (List Char)]Char
letter! = sat isLetter

digit : [Exception ParseError, State (List Char)]Char
digit! = sat isDigit 

alphanum : [Exception ParseError, State (List Char)]Char
alphanum! = por digit letter  

word : [Exception ParseError, State (List Char)] (List Char)
word! = some letter 

number : [Exception ParseError, State (List Char)] (List Char)
number! = some digit
