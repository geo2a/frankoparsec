-- do m, do n, return the result of doing m. 
-- Due to call-by-value, this is actually a ';' or '>>'
fst : X -> Y -> X
fst x y = x

-- sequencing
on : X -> {X -> Y} -> Y
on x f = f x

-- lazy conditional
if : Bool -> {X} -> {X} -> X
if true  t f = t!
if false t f = f!

map : {X -> Y} -> List X -> List Y
map f nil         = nil
map f (cons x xs) = cons (f x) (map f xs)

foldl : {Y -> X -> Y} -> Y -> (List X) -> Y
foldl g acc nil       = acc
foldl g acc (x :: xs) = foldl g (g acc x) xs


data Bool = true | false

{--- Natural numbers and Ints ---}

data Nat = zero | suc Nat

eqNat : Nat -> Nat -> Bool
eqNat zero zero  = true
eqNat (suc x) (suc y) = eqNat x y
eqNat zero _     = false
eqNat _  zero    = false

plusNat : Nat -> Nat -> Nat
plusNat zero y = y
plusNat (suc x) y = suc (plusNat x y)

eqInt : Int -> Int -> Bool 
eqInt 0 0 = true 
eqInt 0 _ = false
eqInt _ 0 = false
eqInt x y = eqInt (x - 1) (y - 1)

{--- Lists ---}

append : List X -> List X -> List X
append nil ys         = ys
append (cons x xs) ys = cons x (append xs ys)

concat : (List (List X)) -> List X
concat xs = foldl {x y -> append x y} nil xs

{--- Other ---}

data Zero =     -- empty type

data Maybe A = just A | nothing

data Either A B = left A | right B
{--- Chars and strings ---}

eqChar : Char -> Char -> Bool
eqChar 'a' 'a' = true
eqChar 'b' 'b' = true
eqChar 'c' 'c' = true
eqChar 'd' 'd' = true
eqChar 'e' 'e' = true
eqChar 'f' 'f' = true
eqChar 'g' 'g' = true
eqChar 'h' 'h' = true
eqChar 'i' 'i' = true
eqChar 'j' 'j' = true
eqChar 'k' 'k' = true
eqChar 'l' 'l' = true
eqChar 'm' 'm' = true
eqChar 'n' 'n' = true
eqChar 'o' 'o' = true
eqChar 'p' 'p' = true
eqChar 'q' 'q' = true
eqChar 'r' 'r' = true
eqChar 's' 's' = true
eqChar 't' 't' = true
eqChar 'u' 'u' = true
eqChar 'v' 'v' = true
eqChar 'w' 'w' = true
eqChar 'x' 'x' = true
eqChar 'y' 'y' = true
eqChar 'z' 'z' = true
eqChar '0' '0' = true
eqChar '1' '1' = true
eqChar '2' '2' = true
eqChar '3' '3' = true
eqChar '4' '4' = true
eqChar '5' '5' = true
eqChar '6' '6' = true
eqChar '7' '7' = true
eqChar '8' '8' = true
eqChar '9' '9' = true
eqChar ' ' ' ' = true
eqChar '\n' '\n' = true
eqChar '\t' '\t' = true
eqChar _   _   = false 

toUpper : Char -> Char
toUpper 'a' = 'A'
toUpper 'b' = 'B'
toUpper 'c' = 'C'
toUpper 'd' = 'D'
toUpper 'e' = 'E'
toUpper 'f' = 'F'
toUpper 'g' = 'G'
toUpper 'h' = 'H'
toUpper 'i' = 'I'
toUpper 'j' = 'J'
toUpper 'k' = 'K'
toUpper 'l' = 'L'
toUpper 'm' = 'M'
toUpper 'n' = 'N'
toUpper 'o' = 'O'
toUpper 'p' = 'P'
toUpper 'q' = 'Q'
toUpper 'r' = 'R'
toUpper 's' = 'S'
toUpper 't' = 'T'
toUpper 'u' = 'U'
toUpper 'v' = 'V'
toUpper 'w' = 'W'
toUpper 'x' = 'X'
toUpper 'y' = 'Y'
toUpper 'z' = 'Z'

isLetter : Char -> Bool
isLetter 'a' = true
isLetter 'b' = true
isLetter 'c' = true
isLetter 'd' = true
isLetter 'e' = true
isLetter 'f' = true
isLetter 'g' = true
isLetter 'h' = true
isLetter 'i' = true
isLetter 'j' = true
isLetter 'k' = true
isLetter 'l' = true
isLetter 'm' = true
isLetter 'n' = true
isLetter 'o' = true
isLetter 'p' = true
isLetter 'q' = true
isLetter 'r' = true
isLetter 's' = true
isLetter 't' = true
isLetter 'u' = true
isLetter 'v' = true
isLetter 'w' = true
isLetter 'x' = true
isLetter 'y' = true
isLetter 'z' = true
isLetter 'A' = true
isLetter 'B' = true
isLetter 'C' = true
isLetter 'D' = true
isLetter 'E' = true
isLetter 'F' = true
isLetter 'G' = true
isLetter 'H' = true
isLetter 'I' = true
isLetter 'J' = true
isLetter 'K' = true
isLetter 'L' = true
isLetter 'M' = true
isLetter 'N' = true
isLetter 'O' = true
isLetter 'P' = true
isLetter 'Q' = true
isLetter 'R' = true
isLetter 'S' = true
isLetter 'T' = true
isLetter 'U' = true
isLetter 'V' = true
isLetter 'W' = true
isLetter 'X' = true
isLetter 'Y' = true
isLetter 'Z' = true
isLetter _   = false

isDigit : Char -> Bool
isDigit '0' = true
isDigit '1' = true
isDigit '2' = true
isDigit '3' = true
isDigit '4' = true
isDigit '5' = true
isDigit '6' = true
isDigit '7' = true
isDigit '8' = true
isDigit '9' = true
isDigit _   = false

isSpace : Char -> Bool
isSpace ' '  = true
isSpace '\n' = true
isSpace '\t' = true
isSpace _    = false
interface State S = get : S
                  | put : S -> Unit

state : S -> <State S>X -> X
state _ x          = x
state s <get -> k>  = state s (k s)
state _ <put s -> k>  = state s (k unit)

interface Exception E
  = exception : E -> Zero

throw : E -> [Exception E]X
throw e = on (exception e) {}

catch : <Exception E>X -> Either E X
catch x = right x
catch <exception e -> _> = left e
data Pair A B = pair A B 

data ParseError = err

interface Parser = fail : ParseError -> Char
                 | sat : {Char -> Bool} -> Char
                 | choose : {[Parser] Char} -> {[Parser] Char} -> Char

runParser : (List Char) -> <Parser>Char -> 
            Either ParseError (Pair Char (List Char))
runParser xs r = right (pair r xs)
runParser _ <fail err -> _> = left err
runParser nil <sat p -> k> = left err
runParser (x::xs) <sat p -> k> = 
  if (p x) {runParser xs (k x)} {runParser nil (fail err)}
runParser xs <choose p1 p2 -> k> = 
  on (runParser xs p1!)
    { (right _) -> runParser xs p1!
    | (left err) -> on (runParser xs p2!) 
      { (right _) -> runParser xs p2!
      | (left err) -> left err
      }
    }

parse : (List Char) -> {[Parser]Char} -> 
        Either ParseError Char
parse xs p = on (runParser xs p!) 
  { (right (pair y ys)) -> right y 
  | (left          err) -> left err
  } 

char : Char -> [Parser]Char
char c = sat {x -> eqChar x c}

letter : [Parser]Char
letter! = sat isLetter

space : [Parser]Char
space! = char ' '


-- main : {Either ParseError (Pair Char (List Char))}
-- main! = runParser "ab" (sat {x -> eqChar x 'a'})

-- string : (List Char) -> [Parser(List Char)](List Char)
-- string str = map char str 

-- many : {[Parser X]Y} -> [Parser X](List Y) 
-- many p = choose {p! :: many p} {nil}

-- main : {Either ParseError Char}
-- main! = parse "ab" (char 'a')

-- main : {Either ParseError (List Char)}
-- main! = parse "ab" (string "ab")

-- ex : [Parser Char, Console]Unit
-- ex! = on (char 'a') { (right x) -> ouch x
--                     | (left e)  -> unit}

-- ex : [Console]Unit
-- ex! = ouch 'a'


-- main : {Either ParseError (Pair Char (List Char))}
-- main! = runParser "abcsdf dsdsd" (
--   choose {sat {x -> eqChar x 'b'}} {sat {x -> true}}
--   )

-- main : [Console]Unit
-- main! = parse "ab" (ex!)

-- main : {Either ParseError (List Char)}
-- main! = parse "ab" (many {char 'a'})
interface MultiParser = singleton : {[Parser] Char} -> List Char
                      | many : {[Parser] Char} -> List Char

runMultiParser : (List Char) -> <MultiParser>(List Char) -> List Char
runMultiParser _ r = r
runMultiParser xs <singleton p -> k> =
  on (runParser xs p!) { (right (pair ok rest)) -> 
                            ok :: (runMultiParser rest (k nil))  
                       | (left  _) -> nil
                       }
runMultiParser xs <many p -> k> =    
  on (runParser xs p!) 
    { (right (pair ok rest)) -> ok :: (runMultiParser rest (many p; k nil))
    | (left err) -> runMultiParser xs (k nil)
    }

word : [MultiParser](List Char)
word! = many letter

-- main : {List Char}
-- main! = runMultiParser "aab vfd" (many {char 'a'}; singleton {char 'b'}) 

main : {List Char}
main! = runMultiParser "aab vfd" (word!; singleton space; word!) 
-- main : {Either ParseError (List Char)}
-- main! = parse {number!} "123" 