data ParseError = parseError

note 
  Consumes one symbol of any kind
item [Exception ParseError, State (List Char)] Char
item = get! >>= { nil       -> throw parseError
                | (x :: xs) -> put xs >> x} 

note
  Consumes item only if it satisfies given predicate 
sat {Char -> Bool} [Exception ParseError, State (List Char)] Char
sat p = item! >>= {c -> if (p c) then {c} else {throw parseError}}

note
  Consumes item only if it is equal to specified char
char Char [Exception ParseError, State (List Char)] Char
char c = sat {x -> x =Char= c} 

note 
  Parse a specified string
string (List Char) [Exception ParseError, State (List Char)] (List Char)
string str = map char str   

note 
  Interpret parsing as statful computation with possible exceptions
parse {[ Exception ParseError, State (List Char)] X}
      (List Char) [] Maybe X
parse p str = catch' ? state str ? p!

note 
  Alternative-like operation: try first parser, if it fails -- try second one

  Type are as ugly as my life, we need something to make them look more pretty.

{[Exception ParseError, State (List Char)] X} <|> {[Exception ParseError, State (List Char)] X} [Exception ParseError, State (List Char)] X   
p1 <|> p2 = get! >>= 
  {xs -> parse p1 xs >>= 
    { (just str) -> p1!
    | nothing -> parse p2 xs >>= 
      { (just str) -> p2!
      | nothing -> throw parseError
      }
    }
  }

note
  Видимо, строгость языка тут накладывает серьёзные ограничения на удобство. 
  Не очень понятно, как конструировать длинные цепочки вычислений, тут каждое 
  вычисление выполняется сразу.

note 
  Zero or more 
many {[Exception ParseError, State (List Char)] X} 
     [Exception ParseError, State (List Char)]
     (List X)
many p = {some p} <|> {nil}

note 
  One or more
some {[Exception ParseError, State (List Char)] X} 
     [Exception ParseError, State (List Char)] 
     (List X)
some p = p! >>= {x -> many p >>= {xs -> x :: xs}}

isLetter Char [] Bool
isLetter c = c =Char= 'a'

letter [Exception ParseError, State (List Char)] Char
letter = sat isLetter
 
word [Exception ParseError, State (List Char)] (List Char)
word = some {letter} 

note 
  p_ex [Exception ParseError, State (List Char)] Char
  p_ex = {item} <|> {item}

note 
main [] Maybe (List Char)
main = parse {word} ('a' :: ('a' :: (' ' :: nil)))

note 
  main [] Maybe (List Char)
  main = parse {string ('a' :: ('b' :: nil))} ('a' :: ('b' :: nil))

note
  main [] Maybe Char
  main = parse {{char 'c'} <|> {char 'a'}} ('a' :: ('b' :: nil))

note 
  main [] Either ParseError Char
  main = catch ? state ('a' :: ('b' :: nil)) ? item! >> item!

  main [State (List Char)] Either ParseError Char
  main = catch ? item! >> item!

note 
  main [] Either ParseError (List Char)
  main = catch ? state ('a' :: ('b' :: nil)) ? string ('a' :: ('b' :: nil))

note 
  main [] Either ParseError Char
  main = catch ? state nil ? item!